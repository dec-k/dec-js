<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Declan K. Portfolio</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!--<link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">-->

  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">

  <!--<script language="javascript" type="text/javascript" src="js/cjs.js"></script>
  <script language="javascript" type="text/javascript" src="js/p5/p5.min.js"></script>
  <script language="javascript" type="text/javascript" src="js/p5/addons/p5.dom.min.js"></script>-->

  <link rel="icon" type="image/png" href="images/favicon.png">
</head>
<body>
  <div class="container">
    <div class="row">
      <div class="one-half column" style="margin-top: 10%">
        <h1 id="head-block">Declan Keighley</h1>
        <h2 id="sub-block">Sound-Switch Retrospect</h2>
        <p>
          This page is a retrospective view of my senior project, developed in my final year of the
          Bachelor's of Information Technology at Otago Polytechnic.
        </p>
        <p>
          The project's goal was to create an easily accessible, open-source accessibility tool for those with motor impairments.
          The currently available voice-to-input solutions are prohibitively expensive for much of their audience,
          so we aim to remedy that with our free alternative.
        </p>
        <p>
          The repository and user-documentation can be found on <a href="https://github.com/OtagoPolytechnic/SoundSwitch">here</a>.<br>
          Developer / Tinkerer code documentation is found in the project itself, every method and command is thoroughly commented.
        </p>
        <p>
          A modified version of the library <a href="https://github.com/openpreserve/scape-xcorrsound">xcorr-sound</a> was used in our project for the purpose of determining the similarity of one audio file to another.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="12 columns" style="margin-top: 10%">
        <h4>On Reflection</h4>
        <p class="u-full-width">
          Now that this project is reaching some sort of closure, I’m going to talk about what I feel went well, what went poorly, and all the in-betweens.  Before I get into the finer points, I want to say I’ve had a fantastic time working on this project in my final semester. We hit our stride, quickly overcame problems, and built a more-or-less fully functioning program by the end. Our first semester was very difficult – we were swimming in unfamiliar waters. No audio experience, and minimal experience with thinking outside of a set of the code guidelines provided by assignments. I found this semester to be a very rewarding problem-solving experience, and I’m surprisingly proud of the end result.
        </p>
        <p>
          First up, what I feel went well. We came into the second semester after taking a short break from actively working on the project, and we were aware of our now limited time to produce something for a user. We decided to begin actively fleshing out the user-facing GUI for our final application, as well as the code on the back end that would facilitate the reading and matching of audio. Both Leonard and I put in a great deal of work to get this initial prototype going, and it did – sort of. Through some long days and a huge amount of google & teamwork, Leonard and I managed to get a real working prototype. I feel our teamwork really shone this semester, we communicated constantly and actually began really enjoying the time we were investing into our project. Both of us were involved in every major decision step of our project, and the result came out great.
        </p>
        <p>
          The poorer parts of my project experience are more entrenched in the first semester of project. I found it very difficult to understand all of the moving pieces that would be required to make our project plan a reality. And as I mentioned earlier, neither me nor Leonard had any experience with audio files and we lacked confidence with languages other than C# / Web. A recurring issue we had involved our search for an appropriate library to help us with the audio comparison part - to write our own required programming knowledge well beyond our current level. We spent a great many hours searching for solutions, often spending days trying to get a given library to function, only to find that it didn't function in the way we needed. Partly due to this problem, we had one particular time where neither of us wanted to work, and we felt stuck in a rut for about 2 weeks - nothing was achieved. I still feel bad about this, but as soon as the second semester started we made a great comeback. My biggest personal problem was finding a direction to run in for this project, as well as overcoming the initial burnout while we were still planning our project and trying to find libraries or tools to offload the overly complex parts of our assignment, such as the part of our program that compares the audio files.
        </p>
        <p>
          In conclusion, our project had a very rocky start, due to my lack of direction and much uncertainty of how viable the end result would be. However, as soon as I had even a semblance of a direction and a plan, work speed and progress increased rapidly. I loved being able to solve the interesting problems this project provided, from things like culling ambient noise, to storing bindings between runs, and to fine-tuning the optimisation of those bindings to increase their execution speed. Leonard and I worked extremely well together, and that teamwork and pacing between the two of us made this project very fun to develop.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="12 columns" style="margin-top: 10%">
        <h4>Interesting Pieces (Code + UI)</h4>
        <p>
          This section has a few interesting code snippets that I wrote as part of this project.
        </p>
        <p>
          <b>Best-Match-Bind finding</b><br>
          <b><a href="https://github.com/OtagoPolytechnic/SoundSwitch/blob/master/sound-switch/sound-switch/BindingManager.cs">Full Class Code Here</a></b><br>
          This code is what drives the most crucial part of the code, the ability to actually match user sounds to bindings.
          It's actual implementation was quite challenging for us, once we
          began using <b>xcorr-sound</b> as our "sound file matching" library,
          we had the issue of that library being solely compiled as cmd executables.
          I did a lot of research into running cmd processes and returning information from that process
          efficiently. Initially, I tried to run the CMD process in a multi-threaded way
          but I discovered that this approach is quite overengineered for what we required.
          I ended up rewriting this section to work so that each run over the for loop in the snippet
          uses a custom class I wrote (executor) which handles all the process start-stopping, and
          provides a method that allows a command to be passed to that process and returns the commands output.<br>
          This code also went through a couple iterations, before the executor code was fully modularised,
          the latency on finding bindings was unacceptably slow and it required revising to get to where it is now.
        </p>
      <pre><code>
          public Binding compareUnprocessed()
          {
            //Loop over each stored binding and execute the compare script on each of them.
            for (int i = 0; i < bindings.Count; i++)
            {
                //Build the command we wish to send to the overlap-analysis executable.
                string commandToExecute = pathToScript + " " + bindings[i].pathToWav + ".wav " + pathToUnprocessed;

                //Pass the command to the executor instance, and retrieve the result as a double (for comparison).
                compareResults[i] = Convert.ToDouble(executor.ExecuteCommand(commandToExecute));
            }

            //Find the index which holds the highest value in the array

            double bestMatchValue = Convert.ToDouble(compareResults.Max());
            int bestMatchIndex = Array.IndexOf(compareResults, bestMatchValue);

            if (bestMatchValue < ProgramSettings.quality)
            {
                return null;
            }
            else
            {
                return bindings[bestMatchIndex];
            }
        }
      </code></pre>

      <p>
        <b>Existing Bind Loading</b><br>
        <b><a href="https://github.com/OtagoPolytechnic/SoundSwitch/blob/master/sound-switch/sound-switch/BindingManager.cs">Full Class Code Here</a></b><br>
        We had an interesting problem relating to the persistence of our
        bindings. In that we didn't have any. When I first wrote the system to manage
        bindings, we lost all binding data between launches. I started looking for good options
        that would afford us persistence between launches, but none seemed very practical
        for the small file-size required by our sounds (I even considered trying to Serialise an audio file.)
        So I looked at what data we had for our bindings, and realised I could store all
        information about a given binding <b>in it's own file name.</b> What this lead to is the code you see below,
        when the program is launched, it scans its local directory for .wav files that match our naming conventions,
        then <b>breaks down the file name in order to retrieve the information it needs to recreate the bindings.</b>
        Because we store so little info per-bind, this method has been very fast for us.
      </p>
      <pre><code>
        for (int i = 0; i < dirs.Length; i++)
            {
                //Get relevant path splits at certain characters
                int posSlash = dirs[i].LastIndexOf("\\") + 1;
                int posUnderscore = dirs[i].LastIndexOf("_");
                int posLastPeriod = dirs[i].LastIndexOf(".") - 1;

                //Create intermediaries that store the substrings of the split path.
                string newBindName = dirs[i].Substring(posSlash, posUnderscore - posSlash);

                //Filter out the unprocessed file from the newbind list.
                if (newBindName != "unprocessed")
                {
                    string newBindAction = dirs[i].Substring(posUnderscore + 1, posLastPeriod - posUnderscore);

                    //Create a new binding from these intermediaries.
                    bindings.Add(new Binding(newBindName, newBindAction, true));
                }
      </code></pre>

      <p>
        <b>GUI Layout</b><br>
        <b><a href="https://github.com/OtagoPolytechnic/SoundSwitch/blob/master/sound-switch/sound-switch/HomeForm.cs">Full Class Code Here</a></b><br>
        Although there is code involved here, the code itself isn't very interesting.
        But the approach I used for the design of the GUI is quite interesting.
        We didn't want a cumbersome, unwieldy design as usability was very important to us,
        especially given the potentially limited motor-function of our target audience.
        The entire app (save for 1 form) takes place on <b> the same form, using stacked panels that
        show/hide as needed</b>. I did this to keep persistence and scope of all the working parts
        of our program at once, without having to awkwardly pass instances between different form instances.
        The end result makes pre-loading certain pieces of information much easier, and lets the user
        move around screens seamlessly without having to turn listening off or reset their audio device.
      </p>
      <img src="assets/home.png"/><br>
      <p>
        Additionally, the one seperate form we do have is the form for creating a new binding.
        Again, the code behind the form itself doesn't do much thats very
        interesting, but the design had to try and be sensible and avoid
        being overbearing for the user - this dialog went through a few iterations
        before we agreed to settle on what you see below, previously, whenever people used
        it, they found the window quite confusing and weren't really sure what
        the program was after. I hope I remedied it with this UI.
      </p>
      <img src="assets/newbind.png"/>

      </div>
    </div>
    <!--<div class="row">
      <div class="12 columns" style="margin-top: 10%">
        <h4>Self-Review</h4>
        <p>Here is my self-assessment. Each category is on a scale of 1-5, with 5 being best.</p>
        <p>
          <b>How well does your final deliverable work?</b><br>
          <span style="font-size:200%;">4/5</span><br>
          <b>Comment:</b><br> I'm very satisfied with our final deliverable. It does
          all expected tasks that were outlined with our project leader at the
          beginning of the year, however it can sometimes underperform in terms
          of speed. We are unsure what the best option is to further optimise the speed.
        </p><br>

        <p>
          <b>How well does your final deliverable work?</b><br>
          <span style="font-size:200%;">4/5</span><br>
          <b>Comment:</b><br> I'm very satisfied with our final deliverable. It does
          all expected tasks that were outlined with our project leader at the
          beginning of the year, however it can sometimes underperform in terms
          of speed. We are unsure what the best option is to further optimise the speed.
        </p><br>

    </div>-->
  </div>
</body>
</html>
